/*
 * Tramvajske stanice
 *
 * API napravljen u sklopu 3. laboratorijske vježbe za predmet Otvoreno Računalstvo. Definira operacije koje nude mogućnosti manipuliranja skupa podataka o tramvajskim stanicama.
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"fmt"
	"context"
	"encoding/json"
	"time"
	"net/http"
	"github.com/gorilla/mux"
	"github.com/jackc/pgx/v5"
)

type Stanica struct {
 ID           int       `json:"id"`
 Name  	      string    `json:"name"`
 Description  string    `json:"description"`
 Note  	      string    `json:"note"`
 CoordinateX  float32   `json:"coordinateX"`
 CoordinateY  float32   `json:"coordinateY"`
 NextStop     string    `json:"nextStop"`
 PreviousStop string    `json:"previousStop"`
 DateBuilt    time.Time `json:"dateBuilt"`
}

type ResponseStations struct {
	Status  string               `json:"status"`
	Message string               `json:"message"`
	Data    ResponseDataStations `json:"response"`
}

type ResponseDataStations struct {
	Stations []Stanica `json:"stations"`
}

func StationsGet(conn *pgx.Conn) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		rows, err := conn.Query(context.Background(), "SELECT * FROM tram_stops")
		if err != nil {
			http.Error(w, "Error querying database", http.StatusInternalServerError)
			return
		}
		defer rows.Close()

		var stanice []Stanica
		for rows.Next() {
			var stanica Stanica
			err := rows.Scan(&stanica.ID, &stanica.Name, &stanica.Description, &stanica.Note, &stanica.CoordinateX, &stanica.CoordinateY, &stanica.NextStop, &stanica.PreviousStop, &stanica.DateBuilt)
			if err != nil {
				http.Error(w, "Error scanning database rows", http.StatusInternalServerError)
				return
			}
			stanice = append(stanice, stanica)
		}

		responseData := ResponseDataStations{
			Stations: stanice,
		}

		response := ResponseStations{
			Status:  "OK",
			Message: "Fetched station data",
			Data:    responseData,
		}

		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		w.WriteHeader(http.StatusOK)

		if err := json.NewEncoder(w).Encode(response); err != nil {
			http.Error(w, "Error encoding response to JSON", http.StatusInternalServerError)
			fmt.Println(err)
			return
		}
	}
}

func StationsIdDelete(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func StationsIdGet(conn *pgx.Conn) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        vars := mux.Vars(r)
        id := vars["id"]

        var stanica Stanica
        err := conn.QueryRow(context.Background(), "SELECT * FROM tram_stops WHERE id = $1", id).Scan(&stanica.ID, &stanica.Name, &stanica.Description, &stanica.Note, &stanica.CoordinateX, &stanica.CoordinateY, &stanica.NextStop, &stanica.PreviousStop, &stanica.DateBuilt)

        if err != nil {
            if err == pgx.ErrNoRows {
                response := ResponseStations{
                    Status:  "NOT FOUND",
                    Message: "Station with specified ID not found",
                    Data:    ResponseDataStations{Stations: nil},
                }

                w.Header().Set("Content-Type", "application/json; charset=UTF-8")
                w.WriteHeader(http.StatusNotFound)
                if err := json.NewEncoder(w).Encode(response); err != nil {
                    http.Error(w, "Error encoding response to JSON", http.StatusInternalServerError)
                    fmt.Println(err)
                }
                return
            } else {
                http.Error(w, "Error querying database", http.StatusInternalServerError)
                fmt.Println(err)
                return
            }
        }

        responseData := ResponseDataStations{
            Stations: []Stanica{stanica},
        }

        response := ResponseStations{
            Status:  "OK",
            Message: "Fetched station data",
            Data:    responseData,
        }

        w.Header().Set("Content-Type", "application/json; charset=UTF-8")
        w.WriteHeader(http.StatusOK)

        if err := json.NewEncoder(w).Encode(response); err != nil {
            http.Error(w, "Error encoding response to JSON", http.StatusInternalServerError)
            fmt.Println(err)
            return
        }
    }
}

func StationsIdPut(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func StationsPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func StationsStationIdTramsGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

/*
 * Tramvajske stanice
 *
 * API napravljen u sklopu 3. laboratorijske vježbe za predmet Otvoreno Računalstvo. Definira operacije koje nude mogućnosti manipuliranja skupa podataka o tramvajskim stanicama.
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"fmt"
	"context"
	"encoding/json"
	"net/http"
	"github.com/gorilla/mux"
	"github.com/jackc/pgx/v5"
	
)

type Tramvaj struct {
 ID    int    `json:"lineID,omitempty"`
 Route string `json:"route,omitempty"`
}

type ResponseDataTrams struct {
	Trams []Tramvaj `json:"trams"`
}

type ResponseTrams struct {
	Status  string            `json:"status"`
	Message string            `json:"message"`
	Data    ResponseDataTrams `json:"response"`
}

type ResponseTram struct {
	Status  string            `json:"status"`
	Message string            `json:"message"`
	Data    Tramvaj 	  `json:"response"`
}

type UpdateResponse struct {
	Old Tramvaj `json:"old"`
	New Tramvaj `json:"new"`
}

type UpdateResponseTram struct {
	Status  string            `json:"status"`
	Message string            `json:"message"`
	Data    UpdateResponse 	  `json:"response"`
}

type ResponseTramStations struct {
	Status  string            `json:"status"`
	Message string            `json:"message"`
	Data    []string 	  `json:"response"`
}


// DODANO NOVO ZA JSON-LD

type ListItem struct {
	Type     string   `json:"@type"`
	Position int      `json:"position"`
	Item     TramTrip  `json:"item"`
}

type TramTrip struct {
	Type     string       `json:"@type"`
	ID       int          `json:"identifier"`
	Name     string       `json:"name"`
	Provider ProviderInfo `json:"provider"`
}

type ProviderInfo struct {
	Type string `json:"@type"`
	Name string `json:"name"`
}

type JSONLDResponse struct {
	Context       string      `json:"@context"`
	Type          string      `json:"@type"`
	Name          string      `json:"name"`
	ItemListElement []ListItem `json:"itemListElement"`
}

type WrappedResponse struct {
	Status   string         `json:"status"`
	Message  string         `json:"message"`
	Response JSONLDResponse `json:"response"`
}

type JSONLDTramStop struct {
	Type string `json:"@type"`
	Name string `json:"name"`
}

type StationListItem struct {
	Type     string        `json:"@type"`
	Position int           `json:"position"`
	Item     JSONLDTramStop `json:"item"`
}

type JSONLDItemList struct {
	Context         string     `json:"@context"`
	Type            string     `json:"@type"`
	Name            string     `json:"name"`
	NumberOfItems   int        `json:"numberOfItems"`
	ItemListElement []StationListItem `json:"itemListElement"`
}

type WrappedStationResponse struct {
	Status   string         `json:"status"`
	Message  string         `json:"message"`
	Response JSONLDItemList `json:"response"`
}


func TramsGet(conn *pgx.Conn) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		rows, err := conn.Query(context.Background(), "SELECT * FROM trams")
		if err != nil {
			http.Error(w, "Error querying database", http.StatusInternalServerError)
			return
		}
		defer rows.Close()

		var tramvaji []Tramvaj
		for rows.Next() {
			var tramvaj Tramvaj
			err := rows.Scan(&tramvaj.ID, &tramvaj.Route)
			if err != nil {
				http.Error(w, "Error scanning database rows", http.StatusInternalServerError)
				return
			}
			tramvaji = append(tramvaji, tramvaj)
		}

		var itemListElements []ListItem
		for i, tram := range tramvaji {
			listItem := ListItem{
				Type:     "ListItem",
				Position: i + 1,
				Item: TramTrip{
					Type:     "BusTrip",
					ID:       tram.ID,
					Name:     tram.Route,
					Provider: ProviderInfo{
						Type: "Organization",
						Name: "ZET",
					},
				},
			}
			itemListElements = append(itemListElements, listItem)
		}

		jsonLDResponse := JSONLDResponse{
			Context:       "https://schema.org",
			Type:          "ItemList",
			Name:          "Zagrebački tramvaji",
			ItemListElement: itemListElements,
		}

		wrappedResponse := WrappedResponse{
			Status:   "OK",
			Message:  "Fetched tram data",
			Response: jsonLDResponse,
		}

		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		w.WriteHeader(http.StatusOK)

		if err := json.NewEncoder(w).Encode(wrappedResponse); err != nil {
			http.Error(w, "Error encoding response to JSON-LD", http.StatusInternalServerError)
			fmt.Println(err)
			return
		}
	}
}

func TramsIdDelete(conn *pgx.Conn) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		vars := mux.Vars(r)
		id := vars["id"]

		var deletedTram Tramvaj
		err := conn.QueryRow(context.Background(), "SELECT id, route FROM trams WHERE id = $1", id).Scan(&deletedTram.ID, &deletedTram.Route)
		if err != nil {
		    if err == pgx.ErrNoRows {
			response := ResponseTram{
                    	Status:  "NOT FOUND",
                    	Message: "Tram with specified ID not found",
                   	 Data:    Tramvaj{},
			}
               	    w.Header().Set("Content-Type", "application/json; charset=UTF-8")
               	    w.WriteHeader(http.StatusNotFound)
                    json.NewEncoder(w).Encode(response)
		 } else {
		        http.Error(w, "Error retrieving tram from database", http.StatusInternalServerError)
		    }
		    fmt.Println(err)
		    return
		}

		result, err := conn.Exec(context.Background(), "DELETE FROM trams WHERE id = $1", id)
		if err != nil {
		    http.Error(w, "Error deleting tram from database", http.StatusInternalServerError)
		    fmt.Println(err)
		    return
		}

		rowsAffected := result.RowsAffected()
		if rowsAffected == 0 {
		    http.Error(w, "Tram with specified ID not found", http.StatusNotFound)
		    return
		}

		response := ResponseTram{
			Status:  "OK",
			Message: "Deleted tram object",
			Data:    deletedTram,
		}

		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		w.WriteHeader(http.StatusOK) 
		if err := json.NewEncoder(w).Encode(response); err != nil {
		    http.Error(w, "Error encoding response to JSON", http.StatusInternalServerError)
		    fmt.Println(err)
		    return
		}
	}
}

func TramsIdGet(conn *pgx.Conn) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		vars := mux.Vars(r)
		id := vars["id"]
		
		rows, err := conn.Query(context.Background(), "SELECT id, route FROM trams WHERE id = $1", id)
		if err != nil {
			http.Error(w, "Error querying database", http.StatusInternalServerError)
			return
		}
		defer rows.Close()

		var tramvaji []Tramvaj
		for rows.Next() {
			var tramvaj Tramvaj
			err := rows.Scan(&tramvaj.ID, &tramvaj.Route)
			if err != nil {
				http.Error(w, "Error scanning database rows", http.StatusInternalServerError)
				return
			}
			tramvaji = append(tramvaji, tramvaj)
		}

		var itemListElements []ListItem
		for i, tram := range tramvaji {
			listItem := ListItem{
				Type:     "ListItem",
				Position: i + 1,
				Item: TramTrip{
					Type:     "BusTrip",
					ID:       tram.ID,
					Name:     tram.Route,
					Provider: ProviderInfo{
						Type: "Organization",
						Name: "ZET",
					},
				},
			}
			itemListElements = append(itemListElements, listItem)
		}

		jsonLDResponse := JSONLDResponse{
			Context:       "https://schema.org",
			Type:          "ItemList",
			Name:          "Zagrebački tramvaj",
			ItemListElement: itemListElements,
		}

		wrappedResponse := WrappedResponse{
			Status:   "OK",
			Message:  "Fetched tram data",
			Response: jsonLDResponse,
		}

		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		w.WriteHeader(http.StatusOK)

		if err := json.NewEncoder(w).Encode(wrappedResponse); err != nil {
			http.Error(w, "Error encoding response to JSON-LD", http.StatusInternalServerError)
			fmt.Println(err)
			return
		}
	}
}

func TramsIdPut(conn *pgx.Conn) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        vars := mux.Vars(r)
        oldId := vars["id"]

        var updatedTram Tramvaj
        decoder := json.NewDecoder(r.Body)
        if err := decoder.Decode(&updatedTram); err != nil {
            http.Error(w, "Invalid request body", http.StatusBadRequest)
            fmt.Println(err)
            return
        }
        defer r.Body.Close()

        var existingTram Tramvaj
        err := conn.QueryRow(context.Background(), "SELECT id, route FROM trams WHERE id = $1", oldId).Scan(&existingTram.ID, &existingTram.Route)
        if err != nil {
            if err == pgx.ErrNoRows {
                http.Error(w, "Tram with specified ID not found", http.StatusNotFound)
            } else {
                http.Error(w, "Error retrieving tram from database", http.StatusInternalServerError)
            }
            fmt.Println(err)
            return
        }

	if updatedTram.ID != existingTram.ID || updatedTram.Route != existingTram.Route {
        	err = conn.QueryRow(context.Background(), "UPDATE trams SET id = $1, route = $2 WHERE id = $3 RETURNING id, route", updatedTram.ID, updatedTram.Route, oldId).Scan(&updatedTram.ID, &updatedTram.Route)
        }

        if err != nil {
            http.Error(w, "Error updating tram in database", http.StatusInternalServerError)
            fmt.Println(err)
            return
        }

	responseData := UpdateResponse{
		Old: existingTram,
		New: updatedTram,
	}

	response := UpdateResponseTram{
		Status:  "OK",
		Message: "Updated tram object",
		Data:    responseData,
	}

        w.Header().Set("Content-Type", "application/json; charset=UTF-8")
        w.WriteHeader(http.StatusOK)
        if err := json.NewEncoder(w).Encode(response); err != nil {
            http.Error(w, "Error encoding response to JSON", http.StatusInternalServerError)
            fmt.Println(err)
            return
        }
    }
}

func TramsPost(conn *pgx.Conn) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
    	var createReq Tramvaj
        decoder := json.NewDecoder(r.Body)
        if err := decoder.Decode(&createReq); err != nil {
            http.Error(w, "Invalid request body", http.StatusBadRequest)
            fmt.Println(err)
            return
        }
        defer r.Body.Close()
        
        if createReq.Route == "" {
            http.Error(w, "Route of the tram can not be empty", http.StatusBadRequest)
            return
        }

        var newTramId int
        err := conn.QueryRow(context.Background(), "INSERT INTO trams (id, route) VALUES ($1, $2) RETURNING id", createReq.ID, createReq.Route).Scan(&newTramId)
        if err != nil {
            http.Error(w, "Error inserting into database", http.StatusInternalServerError)
            fmt.Println(err)
            return
        }

        var newTram Tramvaj
        err = conn.QueryRow(context.Background(), "SELECT * FROM trams WHERE id = $1", newTramId).Scan(&newTram.ID, &newTram.Route)
        if err != nil {
            http.Error(w, "Error retrieving newly created tram", http.StatusInternalServerError)
            fmt.Println(err)
            return
        }

	response := ResponseTram{
		Status:  "OK",
		Message: "Created tram object",
		Data:    newTram,
	}

        w.Header().Set("Content-Type", "application/json; charset=UTF-8")
        w.WriteHeader(http.StatusCreated)
        if err := json.NewEncoder(w).Encode(response); err != nil {
            http.Error(w, "Error encoding response to JSON", http.StatusInternalServerError)
            fmt.Println(err)
            return
        }
    }
}

func TramsTramIdStationsGet(conn *pgx.Conn) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
    	vars := mux.Vars(r)
		id := vars["id"]
		
		rows, err := conn.Query(context.Background(), `SELECT ts.name
							       FROM tram_stops ts
							       JOIN tram_stops_trams tst ON ts.id = tst.tram_stop_id
							       WHERE tst.tram_id = $1`, id)
		if err != nil {
			http.Error(w, "Error querying database", http.StatusInternalServerError)
			return
		}
		defer rows.Close()

		var stanice []string
		for rows.Next() {
			var stanica string
			err := rows.Scan(&stanica)
			if err != nil {
				http.Error(w, "Error scanning database rows", http.StatusInternalServerError)
				return
			}
			stanice = append(stanice, stanica)
		}

		var listItems []StationListItem
		for i, station := range stanice {
			listItems = append(listItems, StationListItem{
				Type:     "ListItem",
				Position: i + 1,
				Item: JSONLDTramStop{
					Type: "BusStop",
					Name: string(station),
				},
			})
		}

		jsonLDItemList := JSONLDItemList{
			Context:         "https://schema.org",
			Type:            "ItemList",
			Name:            "Stops for tram " + id,
			NumberOfItems:   len(stanice),
			ItemListElement: listItems,
		}

		wrappedResponse := WrappedStationResponse{
			Status:   "OK",
			Message:  "Fetched station data for the tram",
			Response: jsonLDItemList,
		}

		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		w.WriteHeader(http.StatusOK)

		if err := json.NewEncoder(w).Encode(wrappedResponse); err != nil {
			http.Error(w, "Error encoding response to JSON", http.StatusInternalServerError)
			fmt.Println(err)
			return
		}
	}
}
